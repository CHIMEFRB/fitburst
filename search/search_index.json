{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"fitburst","text":"<p>Weclome to the documentation of <code>fitburst</code>, a Python codebase for direct modeling of radio dynamic spectra from fast radio bursts (FRBs) and pulsars! In these pages, you will find a concise and evolving set of instructions for how to use <code>fitburst</code> and its features, as well as a basic guideline for further development.</p>"},{"location":"about/","title":"fitburst - About","text":"<p><code>fitburst</code> offers a collection of Python structures for fitting two-dimensional dynamic spectra of dispersed radio pulses in terms of basic physical parameters. <code>fitburst</code> is currently able to model spectra that contain a single burst or multiple \"sub-bursts\", as is typically observed in repeating FRBs (e.g., Hessels et al., 2019). </p> <p>In its most general configuration, <code>fitburst</code> will determine a best-fit model of the spectrum \\(S_i = A_i F_i T_i\\) for the \\(i\\)th sub-burst, where \\(A_i\\) is the global amplitude of the sub-burst signal and the other two terms are each functions of several parameters:</p> <ol> <li>the term \\(F_i \\equiv F_i(\\gamma_i, r_i)\\) encodes the spectral energy distribution of the \\(i\\)th burst, assuming a \"running\" power-law distribution where \\(\\gamma_i\\) is the spectral index, \\(r_i\\) is the \"running\" of the spectral index, and \\(f_0\\) is a fixed reference frequency;</li> </ol> \\[ F_i = (f/f_0)^{-\\gamma_i + r_i\\ln{(f/f_0)}} \\] <ol> <li>the term \\(T_i \\equiv T_i({\\rm DM}, t_{{\\rm arr},i}, w_i, \\tau_0)\\) characterizes the temporal shape of the \\(i\\)th sub-burst. In the frequency-dependent scattering timescale (\\(\\tau_0\\)) is non-zero, then <code>fitburst</code> will fit a pulse broadening function McKinnon et al., 2014 as the temporal shape, where \\(\\tau = \\tau_0(f/f_0)^\\alpha\\) and </li> </ol> \\[ T_i = \\frac{1}{2\\tau}\\exp{\\bigg(\\frac{w_i^2}{2\\tau^2} - \\bigg[\\frac{(t({\\rm DM}) - t_{{\\rm arr}, i})}{\\tau}\\bigg]}\\bigg)\\bigg\\{1 + {\\rm erf}\\bigg[\\frac{t({\\rm DM}) - (t_{{\\rm arr}, i} + w_i^2/\\tau)}{w_i\\sqrt{2}}\\bigg]\\bigg\\} \\] <p>where \\(t({\\rm DM})\\) is the arrival of the pulse with a non-zero dispersion measure (\\({\\rm DM}\\)) and \\(w_i\\) is the \"intrinsic\" width of the un-scattered (Gaussian) profile. If instead \\(\\tau_0\\) is sufficiently small (i.e., if scattering is negligible), then we instead model the temporal shape of the burst as a Gaussian distribution of widths \\(w_i\\)</p>"},{"location":"installation/","title":"fitburst - Installation","text":""},{"location":"installation/#building-from-pypi","title":"Building from <code>PyPI</code>","text":"<p><code>fitburst</code> will soon be retrievable from the Python Package Index (PyPI) via pip.</p>"},{"location":"installation/#building-from-source","title":"Building from Source","text":"<p>The <code>fitburst</code> codebase uses either <code>pip</code> or poetry for building the distribution and grabbing dependencies. The easiest route to building <code>fitburst</code> is to use <code>pip</code>:</p> <pre><code>&gt; git clone https://github.com/CHIMEFRB/fitburst.git\n&gt; cd fitburst/\n&gt; pip install .\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>For out-of-the-box use, <code>fitburst</code> currently depends on the external Python packages listed below. We encourage interested developers to contribute software and/or replace existing functionality with new dependencies; however, we request that any additional dependency be open-source, meaningfully used, and accessible via <code>pip</code>.</p> <ul> <li>Python 3.8 or greater</li> <li>matplotlib</li> <li>mkdocs</li> <li>numpy</li> <li>pandas</li> <li>pytz</li> <li>pyyaml</li> <li>scipy</li> </ul>"},{"location":"installation/#developer-dependencies","title":"Developer Dependencies","text":"<p>There are additional dependencies for folks who wish to contribute and build code, tests, and/or documentation. These dependenices are listed in the <code>pyproject.toml</code> file under the <code>tools.poetry.group.*.dependencies</code> attributes. However, these dependencies currently can only be installed using <code>poetry</code> due to way in which <code>pip</code> understands the <code>pyproject.toml</code> file.</p>"},{"location":"developer_guide/package_structure/","title":"Package Structure","text":""},{"location":"developer_guide/package_structure/#package-structure","title":"Package Structure","text":"<p>The <code>fitburst</code> codebase is organized into five distinct sub-directories that contain different types of algorithms and structures:</p> <ul> <li><code>analysis/</code>: functions and objects relevant to the modeling of radio dynamic spectra;</li> <li><code>backend/</code>: configuration data and project-specific I/O structures;</li> <li><code>pipelines/</code>: executables that use the <code>fitburst</code> API;</li> <li><code>routines/</code>: basic functions that define physical features of radio spectra;</li> <li><code>utilities/</code>: functions and objects used for pre-processing of data;</li> </ul>"},{"location":"developer_guide/philosophy/","title":"fitburst - Development Philosophy","text":""},{"location":"developer_guide/philosophy/#coding-style","title":"Coding Style","text":""},{"location":"developer_guide/philosophy/#unit-conventions","title":"Unit Conventions","text":"<p>We use the following unit conventions when declaring variables, arrays and/or matricies to be used by <code>fitburst</code>:</p> <ul> <li>the DM is in units of pc cm\\(^{-3}\\);</li> <li>all measures and axes of time are in units of seconds;</li> <li>all measures and axes of electromagnetic frequency are in units of MHz.</li> </ul>"},{"location":"developer_guide/readers/","title":"Writing Data Readers for <code>fitburst</code>","text":"<p>In a pipeline setting, <code>fitburst</code> is designed to isolate all telescope-specific dependencies (e.g., the format and structure of local data archiving servers) to the <code>backend/</code> subdirectory. Here, users are encouraged to write Python objects -- using the <code>utilities.bases.ReaderBaseClass</code> as a foundation -- that enable <code>fitburst</code> to work on their raw data. Once all required, telescope-specific data are successfully loaded into a <code>ReaderBaseClass</code>-compatible structure, the remaining parts of the full <code>fitburst</code> pipeline should work with no issue. (And if there are issues, submit a GitHub issue!)</p>"},{"location":"developer_guide/readers/#the-readerbaseclass-object","title":"The <code>ReaderBaseClass()</code> Object","text":"<p>The <code>ReaderBaseClass()</code> structure is meant to standardize key attributes and methods to be used for downstream processing within <code>fitburst</code>. Users are encouraged to define additional class members that help iniatilize the standard attributes defined in <code>ReaderBaseClass()</code>; however, those telescope-specific members will not be detected or used in later operations.</p>"},{"location":"developer_guide/readers/#key-attributes","title":"Key Attributes","text":"<ul> <li><code>burst_parameters</code>: a Python dictionary containing initial guesses of <code>fitburst</code> parameters</li> <li><code>data_full</code>: a (<code>num_freq</code> x <code>num_time</code>) Numpy array containing the observed spectrum</li> <li><code>data_weights</code>: a list of length <code>num_freq</code>, containing boolean values that indicate whether each channel is usable or masked due to RFI</li> <li><code>dedispersion_idx</code>: TBD</li> <li><code>freqs</code>: a Numpy array containing the frequency centers for each channel</li> <li><code>num_freq</code>: the number of frequency channels in <code>data_full</code></li> <li><code>num_time</code>: the number of time samples in <code>data_full</code></li> <li><code>res_freq</code>: the frequency resolution of <code>data_full</code></li> <li><code>res_time</code>: the time resolution of <code>data_full</code></li> <li><code>times</code>: a Numpy array containing timestamps for each sample</li> </ul>"},{"location":"developer_guide/readers/#key-methods","title":"Key Methods","text":"<ul> <li><code>dedisperse()</code>:</li> <li><code>load_data()</code>:</li> <li><code>preprocess_data()</code>:</li> <li><code>window_data()</code>:</li> </ul>"},{"location":"usage/creating_models/","title":"Creating Models of Spectra","text":"<p>We have developed a Python class, called the <code>SpectrumModeler</code>, for generating models of dynamic spectra. The <code>SpectrumModeler</code> is designed for interaction with downstream fitting routines; however, it can nonetheless be used as a standalone object. The simplest version of a call to the <code>SpectrumModeler</code> is given here: </p> <pre><code>from fitburst.analysis.model import SpectrumModeler\nfreqs = ... # array of frequency labels, in MHz\ntimes = ... # array of timestamps, in seconds\nmodel = SpectrumModeler(freqs, times)\n</code></pre> <p>where (<code>freqs</code>, <code>times</code>) define the centers of frequency channels and time bins, respectively.</p>"},{"location":"usage/creating_models/#parameters-of-the-model-object","title":"Parameters of the Model Object","text":"<p>As described in the <code>fitburst</code> paper, the <code>SpectrumModeler</code> is a function of nine fittable parameters. A tenth parameter, called <code>ref_freq</code> cannot be fitted as it serves as a frequency to which the amplitude and SED parameters are referenced. The full list of parameters can be retrieved as follows:</p> <pre><code>&gt;&gt;&gt; print(model.parameters)\n['amplitude', 'arrival_time', 'burst_width', 'dm', 'dm_index', 'ref_freq', 'scattering_timescale', 'scattering_index', 'spectral_index', 'spectral_running']\n</code></pre> <p>Please refer to Section 2 and Table 1 of the <code>fitburst</code> paper for a description of these parameters.</p>"},{"location":"usage/creating_models/#loading-parameter-values-into-the-model-object","title":"Loading Parameter Values into the Model Object","text":"<p>In order to load parameter values, we use the <code>update_parameters()</code> method of the <code>SpectrumModeler</code>:</p> <pre><code># define dictiomary containing parameter values.\nburst_parameters = {\n    \"amplitude\"            : [0.],\n    \"arrival_time\"         : [0.04],\n    \"burst_width\"          : [0.003],\n    \"dm\"                   : [349.5],\n    \"dm_index\"             : [-2.],\n    \"ref_freq\"             : [1400.],\n    \"scattering_index\"     : [-4.],\n    \"scattering_timescale\" : [0.],\n    \"spectral_index\"       : [10.],\n    \"spectral_running\"     : [-100.],\n}\n\n# now instantiate the SpectrumModeler\nmodel = SpectrumModeler(freqs, times)\n\n# update the SpectrumModeler to use the above values.\nmodel.update_parameters(burst_parameters)\n\n# slightly adjust the DM only, leaving all others unchanged in the model object.\nmodel.update_parameters({\"dm\": [348.95]})\n</code></pre> <p>The <code>update_parameters()</code> method receives a dictionary with one or more parameters with values loaded in Python lists, as shown in the second method call above. This feature exists to allow for flexibility in generating models for fitting where one or more parameters are fixed to pre-determined values.</p>"},{"location":"usage/creating_models/#generating-mulit-component-models","title":"Generating Mulit-Component Models","text":"<p>The <code>SpectrumModeler</code> is also capable of generating models of a multi-component spectrum, i.e., a dynamic spectrum with \\(N\\) distinct pulses. Such models can be created with the same code above, but with values of the <code>burst_parameters</code> dicitionary that are lists of length \\(N\\). For example, the following code will overwrite the above parameters to instantiate a model with 3 components:</p> <pre><code># define dictiomary containing parameter values.\nburst_parameters = {                                                     \n    \"amplitude\"            : [0., 0., 0.], \n    \"arrival_time\"         : [0.03, 0.04, 0.05],\n    \"burst_width\"          : [0.001, 0.003, 0.0005],\n    \"dm\"                   : [349.5, 349.5, 349.5], \n    \"dm_index\"             : [-2., -2., -2.],\n    \"ref_freq\"             : [1400., 1400., 1400.],\n    \"scattering_index\"     : [-4., -4., -4.],\n    \"scattering_timescale\" : [0., 0., 0.],\n    \"spectral_index\"       : [10., 0., -10.],\n    \"spectral_running\"     : [-100., -100., -100.],\n}\n\n# now instantiate the SpectrumModeler for a three-component model.\nnum_components = len(burst_parameters[\"dm\"])\nmodel = SpectrumModeler(freqs, times, num_components = num_components)\n\n# now update Gaussian-SED model object to use the above values.\nmodel.update_parameters(burst_parameters)\n</code></pre>"},{"location":"usage/creating_models/#creating-models-for-de-dispersed-data","title":"Creating Models for De-dispersed Data","text":"<p>Users will typically want to fit models of dynamic spectra against data that are already de-dispersed. The <code>SpectrumModeler</code> can be used as shown above, but with one caveat: the <code>dm</code> parameter is treated as a \"DM offset\" for de-dispersed spectra, instead of the \"full\" DM whose values are supplied in the above examples. Once this configuration is done, we can then compute a model spectrum with the <code>compute_mode()</code> method within the <code>SpectrumModeler</code>.</p> <p>The following code with use the latest example above and perform the adjustment needed for generating a de-dispersed dynamic spectum:</p> <pre><code># indicate whether the spectrum is de-dispersed or not.\nis_dedispersed = True\n\n# define dictiomary containing parameter values.\nburst_parameters = {                                                     \n    \"amplitude\"            : [0., 0., 0.], \n    \"arrival_time\"         : [0.03, 0.04, 0.05],\n    \"burst_width\"          : [0.001, 0.003, 0.0005],\n    \"dm\"                   : [349.5, 349.5, 349.5], \n    \"dm_index\"             : [-2., -2., -2.],\n    \"ref_freq\"             : [1400., 1400., 1400.],\n    \"scattering_index\"     : [-4., -4., -4.],\n    \"scattering_timescale\" : [0., 0., 0.],\n    \"spectral_index\"       : [10., 0., -10.],\n    \"spectral_running\"     : [-100., -100., -100.],\n}\n\n# adjust DM value to zero offset, if necessary.\nnum_components = len(burst_parameters[\"dm\"])\n\nif is_dedispersed:\n    burst_parameters[\"dm\"] = [0.] * num_components\n\n# now instantiate the SpectrumModeler for a three-component model.\nmodel = SpectrumModeler(freqs, times, num_components = num_components)\n\n# grab the model spectrum.\nspectrum_model = model.compute_model()\n</code></pre> <p>The above call with return a NumPy <code>ndarray</code> with shape <code>(num_freq, num_time)</code>.</p>"},{"location":"usage/creating_models/#creating-models-for-dispersed-data","title":"Creating Models for Dispersed Data","text":"<p>In rare or simulation cases, it may be desired to create a dispersed dynamic spectrum. This spectrum can be generated using the latest example above, but instead setting <code>is_dedispersed = False</code>.</p>"},{"location":"usage/formatting_data_generic/","title":"Format of Input Data","text":"<p>For ease of use, we have defined a <code>fitburst</code>-compliant (\"generic\") data format for loading all required data into the <code>fitburst</code> data-reading object. Users can adopt this generic format to ensure initialization of required variables and arrays used within <code>fitburst</code>. The generic-format data are stored in and read from a Python3 Numpy <code>.npz</code> file.</p>"},{"location":"usage/formatting_data_generic/#concept-of-generic-format","title":"Concept of Generic Format","text":"<p>A generic-compatible data file, e.g., \"input_data.npz\", is assumed to contain three entries:</p> <ul> <li><code>metadata</code>: a Python dictionary containing data that describe aspects of the observation;</li> <li><code>burst_parameters</code>: a Python dictionary containing intrinsic burst parameters and their pre-determined values or initial guesses;</li> <li><code>data_full</code>: a NumPy <code>ndarray</code> containing the dynamic spectrum.</li> </ul> <p>These three <code>.npz</code> arrays are defined further below. Once defined, the file can be created by executing the following lines in your local data-preparation script:</p> <pre><code>import numpy as np\n\n# define data_full, metadata and burst_parameter objects as needed.\n# ...\n\n# now write data to file.\nnp.savez(\n    \"input_data.npz\", \n    data_full=data_full, \n    metadata=metadata, \n    burst_parameters=burst_parameters\n)\n</code></pre>"},{"location":"usage/formatting_data_generic/#required-metadata","title":"Required Metadata","text":"<p>The following data in the <code>metadata</code> dictionary are used for configuration of internal arrays, and are not parameters considered for least-squares optimization.</p> <pre><code>metadata = {\n    \"bad_chans\"      : # a Python list of indices corresponding to frequency channels to zero-weight\n    \"freqs_bin0\"     : # a floating-point scalar indicating the value of frequency bin at index 0, in MHz\n    \"is_dedispersed\" : # a boolean indicating if spectrum is already dedispersed (True) or not (False)\n    \"num_freq\"       : # an integer scalar indicating the number of frequency bins/channels\n    \"num_time\"       : # an integer scalar indicating the number of time bins\n    \"times_bin0\"     : # a floating-point scalar indicating the value of time bin at index 0, in MJD\n    \"res_freq\"       : # a floating-point scalar indicating the frequency resolution, in MHz\n    \"res_time\"       : # a floating-point scalar indicating the time resolution, in seconds\n}\n</code></pre>"},{"location":"usage/formatting_data_generic/#required-burst-parameters","title":"Required Burst Parameters","text":"<p>Unless otherwise noted, all data in the <code>burst_parameters</code> dictionary are used as initial guesses and are subject to least-squares optimization. (Only the <code>ref_freq</code> parameter is held fixed permanently; all other parameters can be fitted or held fixed at the discretion of the user.) As with other \"initial-guess\" problems, we recommended that as many initial guesses as possible be \"good enough\" based on prior information. However, the <code>fitburst</code> API allows for initial-guess modifications at later, pre-fit stages. </p> <p>All dictionary keys contain Python lists of floating-point values. The number of list elements is equal to the number of burst components to be modeled. For example, a \"simple\" burst described with a single profile will have <code>burst_parameters</code> entries with <code>len(burst_parameters[name]) = 1</code>.</p> <pre><code>burst_parameters = {\n    \"amplitude\"            : # a list containing the the log (base 10) of the overall signal amplitude\n    \"arrival_time\"         : # a list containing the arrival times, in seconds\n    \"burst_width\"          : # a list containing the temporal widths, in seconds\n    \"dm\"                   : # a list containing the dispersion measures (DM), in parsec per cubic centimeter\n    \"dm_index\"             : # a list containing the exponents of frequency dependence in DM delay\n    \"ref_freq\"             : # a list containing the reference frequencies for arrival-time and power-law parameter estimates, in MHz (held fixed)\n    \"scattering_index\"     : # a list containing the exponents of frequency dependence in scatter-broadening\n    \"scattering_timescale\" : # a list containing the scattering timescales, in seconds\n    \"spectral_index\"       : # a list containing the power-law spectral indices\n    \"spectral_running\"     : # a list containing the power-law spectral running\n}\n</code></pre>"},{"location":"usage/formatting_data_generic/#required-spectrum","title":"Required Spectrum","text":"<p>The <code>data_full</code> entry contains the observed dynamic spectrum as a Numpy <code>ndarray</code> with shape <code>(num_freq, num_time)</code>.</p>"},{"location":"usage/getting_started/","title":"Getting Started","text":"<p>The <code>fitburst</code> codebase can be used in two different ways: as a Python package; or through Python3 scripts provided in the repository. This page describes how to interact with the two usage modes.</p>"},{"location":"usage/getting_started/#fitburst-as-a-python-package","title":"<code>fitburst</code> as a Python package","text":"<p>Once properly installed, <code>fitburst</code> can be immediate accessed through a Python interpreter as an importable package:</p> <pre><code>user@pc &gt; python\n&gt;&gt;&gt; import fitburst\n&gt;&gt;&gt;\n</code></pre> <p>All underlying objects and functions can be accessed in this package format, with Python docstrings that emulate the <code>numpy</code> documentation format.</p>"},{"location":"usage/getting_started/#example-fitburst-pipelines","title":"Example <code>fitburst</code> Pipelines","text":"<p>Any \"full <code>fitburst</code> pipeline\" consists of the following major sections, in order of operation:</p> <ol> <li>command-line interface</li> <li>data I/O</li> <li>declaration of initial guess for burst parameters</li> <li>configuration of <code>fitburst</code> model object</li> <li>configuration of <code>fitburst</code> \"fitter\" object</li> <li>execution of fit</li> <li>generation of figures, fit-summary files, etc.</li> </ol> <p>Of course, some users may be interested in a \"simulation pipeline\" which simulates radio pulses with features they wish to model in the presence of controllable noise. We provide two scripts for interested users to get started in using <code>fitburst</code> under these conditions. Both scripts are located in the pipeline subdirectory of the <code>fitburst</code> codebase. </p> <p>One of these scripts will create a simulated, de-dispersed dynamic spectrum. For example, execute the following lines after compiling <code>fitburst</code>:</p> <pre><code>user@pc&gt; cd /path/to/fitburst/fitburst/pipelines/\nuser@pc | pipelines&gt; python simulate_burst.py\n</code></pre> <p>The output of this script is a plot printed to the screen for reference, and a file in the \"fitburst-generic\" format (<code>simulated_data.npz</code>), described in a separate documentation page, that is saved to the local area. This file contains the simulated spectrum shown in the plot, various parameters that describe the context of the spectrum, and an initial guess of model parameters.</p> <p>The second script is an example of a \"full pipeline\" version of fitburst that performs I/O, model instantiation, and least-squares fitting:</p> <pre><code>user@pc | pipelines&gt; python fitburst_pipeline.py simulated_data.npz --verbose\n</code></pre> <p>The output of this second script consists of three items: a <code>.png</code> file contain a three-panel plot showing the data, best-fit model, and their difference; a JSON file that contains the best-fit parameters and statistics of the fit; and terminal output that shows similar information due to the use of the <code>--verbose</code> option:</p> <pre><code>INFO: no solution file found or provided; proceeding with fit...\nINFO: there are 256 frequencies and 128 time samples.\nINFO: there are 256 good frequencies...\nINFO: input data cube is already dedispersed!\nINFO: setting 'dm' entry to 0, now considered a dm-offset parameter...\nINFO: initial guess for 3-component model:\n    * amplitude: [0.0, 0.0, 0.0]\n    * arrival_time: [0.03, 0.04, 0.05]\n    * burst_width: [0.001, 0.002, 0.0005]\n    * dm: [0.0, 0.0, 0.0]\n    * dm_index: [-2.0, -2.0, -2.0]\n    * ref_freq: [1500.0, 1400.0, 1300.0]\n    * scattering_index: [-4.0, -4.0, -4.0]\n    * scattering_timescale: [0.0, 0.0, 0.0]\n    * spectral_index: [0.0, 0.0, 0.0]\n    * spectral_running: [-300.0, -300.0, -300.0]\nINFO: computing dedispersion-index matrix\nINFO: initializing model\nINFO: removing the following parameters: dm_index, scattering_index, scattering_timescale\nINFO: new list of fit parameters: amplitude, arrival_time, burst_width, dm, spectral_index, spectral_running\n0.00000  0.00000  0.03000   -4.00000  0.00000  0.00100 0.00000  -300.00000\n0.00000  0.00000  0.04000   -4.00000  0.00000  0.00200 0.00000  -300.00000\n0.00000  0.00000  0.05000   -4.00000  0.00000  0.00050 0.00000  -300.00000\n0.02077  0.00435  0.02999   -4.00000  0.00000  0.00096 -0.06705  -301.05914\n0.02077  -0.01179  0.04000   -4.00000  0.00000  0.00204 0.83079  -295.33102\n0.02077  0.02074  0.05001   -4.00000  0.00000  0.00045 0.08439  -272.67249\n0.03633  0.00446  0.02999   -4.00000  0.00000  0.00096 -0.06086  -301.33863\n0.03633  -0.01175  0.04000   -4.00000  0.00000  0.00204 0.83347  -294.97891\n0.03633  0.02339  0.05001   -4.00000  0.00000  0.00046 -0.00992  -275.70777\n0.03592  0.00446  0.02999   -4.00000  0.00000  0.00096 -0.06146  -301.29372\n0.03592  -0.01178  0.04000   -4.00000  0.00000  0.00204 0.83464  -294.98868\n0.03592  0.02348  0.05001   -4.00000  0.00000  0.00046 0.00581  -275.27610\n0.03615  0.00446  0.02999   -4.00000  0.00000  0.00096 -0.06141  -301.29554\n0.03615  -0.01178  0.04000   -4.00000  0.00000  0.00204 0.83460  -294.98740\n0.03615  0.02349  0.05001   -4.00000  0.00000  0.00046 0.00438  -275.31794\nINFO: fit successful!\nINFO: computing hessian matrix with best-fit parameters.\n0.03615  0.00446  0.02999   -4.00000  0.00000  0.00096 -0.06141  -301.29554\n0.03615  -0.01178  0.04000   -4.00000  0.00000  0.00204 0.83460  -294.98740\n0.03615  0.02349  0.05001   -4.00000  0.00000  0.00046 0.00438  -275.31794\n0.03615  0.00446  0.02999   -4.00000  0.00000  0.00096 -0.06141  -301.29554\n0.03615  -0.01178  0.04000   -4.00000  0.00000  0.00204 0.83460  -294.98740\n0.03615  0.02349  0.05001   -4.00000  0.00000  0.00046 0.00438  -275.31794\nINFO: best-fit estimate for 3-component model:\n    * amplitude: [0.004458347857993017, -0.01178052452614616, 0.023488538876660896] +/- [0.011361366063813588, 0.0090246635765475, 0.01652378379027083]\n    * arrival_time: [0.029986353743391356, 0.040002393748902666, 0.050007330750880916] +/- [2.443033563379835e-05, 4.181234443170404e-05, 1.518622689210296e-05]\n    * burst_width: [0.0009574508453823643, 0.002039008450473889, 0.00045508475860427344] +/- [2.403509547560637e-05, 4.033352991181347e-05, 1.906271029135856e-05]\n    * dm: [0.036151607836687895] +/- [0.09274487453599654]\n    * spectral_index: [-0.06141150018163158, 0.8345952746331111, 0.00437634181414019] +/- [0.6464300408655368, 0.4603917717520832, 0.8428930404305951]\n    * spectral_running: [-301.2955381690263, -294.9873984865791, -275.31793520453783] +/- [17.684251952258453, 11.120116046037642, 21.199888485781074]\n</code></pre> <p>The <code>fitburst_pipeline.py</code> script comes with a variety of options that may be useful when working with \"real\" data, but aren't necessary to use for the data simulated above. This script will work with real data so long as the input file matches the \"fitburst-generic\" format of the simulated data; explore these options on real data as you see fit!</p>"},{"location":"usage/using_data_readers/","title":"Working with Data Readers","text":"<p>The <code>fitburst</code> codebase uses a <code>DataReader</code> object for the following purposes:</p> <ol> <li>to ensure that all attributes necessary for downstream analysis are initialized;</li> <li>to provide methods for normalizing and (incoherently) dedispersing the input spectrum, if necessary;</li> <li>to allow for experiment-specific modularity in pipeline settings.</li> </ol>"},{"location":"usage/using_data_readers/#a-base-class-for-data-readers","title":"A Base Class for Data Readers","text":"<p>A <code>DataReader</code> is a child of the <code>ReaderBaseClass</code> object. The <code>ReaderBaseClass</code> object defines all key attributes and nearly all methods used in a typical execution of <code>fitburst</code>. One method of the base class, <code>load_data()</code>, is intentionally left undefined as it depends on the nature of the input data.</p>"},{"location":"usage/using_data_readers/#a-data-reader-for-the-generic-format","title":"A Data Reader for the \"Generic\" Format","text":"<p>As an example of how to use the <code>ReaderBaseClass</code>, we have provided a <code>DataReader</code> that parses the \"generic\" data format discussed on the preceding page. It can be imported and invoked in the following way:</p> <pre><code>from fitburst.backend.generic import DataReader\n\n# read in data stored in the \"generic\" format.\ndata = DataReader()\ndata.load_data(\"input_data.npz\")\n</code></pre>"},{"location":"usage/using_data_readers/#customizing-data-readers","title":"Customizing Data Readers","text":"<p>The <code>DataReader</code> example shown above loads in all data from the input file into the various attributes instantiated by the <code>ReaderBaseClass</code> object. However, it is important to note that all input-dependent steps (e.g., the file format) are encapsulated in the <code>load_data()</code> method only. It is therefore possible to modularize <code>fitburst</code> such that the algorithm can work for a wide range of data formats. The only necessary development would be in creating a new <code>DataReader</code> that can correclty parse the input data format.</p>"},{"location":"usage/using_data_readers/#cleaning-and-flagging-data","title":"Cleaning and Flagging Data","text":"<p>There is a <code>preprocess_data()</code> method in the <code>ReaderBaseClass</code> object that normalizes and baseline-subtracts each channel and determines a set of \"good\" frequencies used by downstream fitting routines. The determination of good and bad frequencies is based on outliers of variance and skewness distributions for the time-averaged spectrum.</p> <p>All options for the <code>preprocess_data()</code> method are optional. Below is an example of its invocation with all arguments set to their default values:</p> <pre><code># now apply cleaning algorithm.\ndata.preprocess_data(\n    normalize_variance = True,\n    skewness_range = [-3., 3.],\n    variance_range = [0.2, 0.8], \n    variance_weight = 1.,\n)\n</code></pre> <p>The above method call with replace the original, raw spectrum stored in <code>data.data_full</code> with the normalized, cleaned spectrum. Also, the above spectrum will overload the <code>data.good_freqs</code> attribute with a list of booleans that indicate frequencies which are deemed useable (<code>True</code>) or unusable (<code>False</code>).</p>"},{"location":"usage/using_data_readers/#retrieving-burst-parameters","title":"Retrieving Burst Parameters","text":"<p>The generic-format data stores previous estimates of the burst parameters in the <code>.npz</code> data file. The <code>DataReader</code> for the generic format then stores these parameters as a Python dicitonary:</p> <p><pre><code># now extract parameters from npz file.\ninitial_parameters = data.burst_parameters\nprint(\"DM values: \", initial_parameters[\"dm\"])\n</code></pre> Let's assume that the <code>input_data.npz</code> file contains data for a three-component burst from FRB 121102, where the burst-averaged DM was previously found to be 557.0 pc cm\\(^{-3}\\). If the <code>.npz</code> file was generated correctly, then the above <code>print()</code> statement should show:</p> <pre><code>DM values: [557.0, 557.0, 557.0]\n</code></pre>"},{"location":"usage/using_data_readers/#dedispersing-andor-windowing-the-input-spectrum","title":"Dedispersing and/or Windowing the Input Spectrum","text":"<p>The <code>ReaderBaseClass</code> contains two algorithms for de-dispersing and windowing the raw spectrum data. These methods are optional, but may be necessary if the input spectrum spans several seconds of data, and/or if the data are either dispersed or de-dispersed to a suboptimal DM value. In all cases, the <code>data.is_dedispersed</code> attribute must accurately reflect whether the input spectrum is already de-dispersed (<code>True</code>) or not (<code>False</code>).</p> <p>Here's an example of a de-dispersion call:</p> <pre><code>data.dedisperse(\n    initial_parameters[\"dm\"][0],\n    initial_parameters[\"arrival_time\"][0],\n    reference_freq = initial_parameters[\"ref_freq\"][0]\n)\n</code></pre> <p>The above call will use the input values and axes information (e.g., <code>data.freqs</code>. <code>data.times</code>, etc.) to compute a map of de-dispersion index values. These index values are then used by the <code>window_data</code> method to obtain a \"windowed\" (i.e., zoomed-in) version of the de-dispersed spectrum:</p> <pre><code>window = 0.08 # in seconds\n\n# before doing anything, check if window size doesn't extend beyond data set.\n# if it does, adjust down by an appropriate amount.\nwindow_max = data.times[-1] - initial_parameters[\"arrival_time\"][0]\n\nif window &gt; window_max:\n    window = window_max - 0.001\n    print(\"INFO: window size adjusted to +/- {0:.1f} ms\".format(window * 1e3))\n\ndata_windowed, times_windowed = data.window_data(params[\"arrival_time\"][0], window=window)\n</code></pre>"}]}